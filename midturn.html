<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Midterm Project — Dream Space Personal Website</title>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #001020;
            color: #ddd;
        }

        nav {
            background: #003366;
            padding: 0.8em;
            display: flex;
            gap: 1em;
            justify-content: center;
        }

            nav a {
                color: #ccc;
                text-decoration: none;
                padding: 0.3em 0.6em;
                border-radius: 4px;
            }

                nav a.active, nav a:hover {
                    background: #0055aa;
                    color: #fff;
                }

        main > section {
            display: none;
            padding: 1em 2em;
            max-width: 900px;
            margin: 0 auto;
        }

            main > section.active {
                display: block;
            }

        h1, h2, h3 {
            color: #88ccee;
        }

        a {
            color: #99ccff;
        }

        .two-col {
            display: flex;
            gap: 1em;
        }

        .profile {
            flex: 1;
            max-width: 220px;
            background: #002244;
            padding: 1em;
            border-radius: 8px;
            text-align: center;
        }

            .profile img {
                width: 150px;
                border-radius: 50%;
                box-shadow: 0 0 8px #3399ff88;
            }

            .profile h3 {
                margin: 0.5em 0 0.2em 0;
                color: #aaddff;
            }

            .profile p {
                font-size: 0.9em;
                color: #99bbdd;
                margin: 0.3em 0 0.5em 0;
            }

        .content {
            flex: 2;
            background: #002f55;
            border-radius: 8px;
            padding: 1em 1.5em;
            color: #ddeeff;
        }

        .gallery-img {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

            .gallery-img img {
                display: block;
                max-width: 400px;
                border-radius: 12px;
            }

        .overlay-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity .4s;
            border-radius: 12px;
        }

        .gallery-img:hover .overlay-img {
            opacity: 1;
        }

        .overlay-text {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 15%;
            background: rgba(0,0,0,0.5);
            color: #ffeecc;
            font-size: 1.2em;
            line-height: 1.5em;
            text-align: center;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }

        .click-zone {
            position: absolute;
            top: 40%;
            left: 40%;
            width: 20%;
            height: 20%;
            cursor: pointer;
        }

        #polaroid-container {
            width: 320px;
            margin: 1em auto 2em auto;
            text-align: center;
        }

        #polaroid-img {
            width: 300px;
            height: 220px;
            padding: 15px 15px 45px 15px;
            background: white;
            box-shadow: 5px 5px 10px rgba(0,0,0,.5);
            border-radius: 12px;
            position: relative;
        }

            #polaroid-img img {
                width: 100%;
                height: auto;
                display: block;
                border-radius: 6px;
            }

        #polaroid-counter {
            position: absolute;
            bottom: 10px;
            width: 100%;
            font-size: 1.1em;
            color: #444;
        }

        .polaroid-btns button {
            margin: 0.5em 0.8em;
            padding: .4em 1.2em;
            font-size: 1em;
            border-radius: 6px;
            border: none;
            background: #0055aa;
            color: white;
            cursor: pointer;
        }

            .polaroid-btns button:hover {
                background: #004488;
            }

        table {
            border-collapse: separate;
            border-spacing: 10px;
            width: 500px;
            margin: 1em auto;
            background: #003366;
            color: #ddeeff;
            border: 3px solid #0055aa;
            border-radius: 6px;
            text-align: center;
            font-size: 1em;
        }

        th, td {
            padding: 10px;
            border: 1px solid #0077cc;
            border-radius: 4px;
        }

        th {
            background: #0055aa;
            font-weight: bold;
        }

        .btn-row {
            text-align: center;
            margin: 0.5em 0;
        }

            .btn-row button {
                margin: 0 .6em;
                padding: .5em 1.2em;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                color: white;
                font-weight: 600;
            }

        #btn-width-200 {
            background: #3366cc
        }

        #btn-width-500 {
            background: #003366
        }

        #btn-border-1 {
            background: #4477aa
        }

        #btn-border-10 {
            background: #225577
        }

        #btn-border-20 {
            background: #113355
        }

        #btn-color-pink {
            background: #ff88aa;
            color: #330011
        }

        #btn-color-lightblue {
            background: #88ccff;
            color: #003355
        }

        #btn-color-lightgreen {
            background: #aaffcc;
            color: #004422
        }

        #btn-reset {
            background: #555555
        }

        #contact p {
            margin: 0.3em 0;
            font-size: 1.1em;
            color: #aaddff;
        }

        #canvas-container {
            margin-top: 2em;
            text-align: center;
        }

        canvas#dream-canvas {
            border-radius: 10px;
            box-shadow: 0 0 20px #0070ff88;
            background: black;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>

    <nav>
        <a href="#" class="active" data-target="home">Home</a>
        <a href="#" data-target="about">About</a>
        <a href="#" data-target="gallery">Gallery</a>
        <a href="#" data-target="showcase">Showcase</a>
        <a href="#" data-target="contact">Contact</a>
    </nav>

    <main>
        <!-- 首頁 -->
        <section id="home" class="active">
            <div id="canvas-container">
                <canvas id="dream-canvas" width="600" height="300"></canvas>
            </div>
        </section>

        <!-- 其餘頁面維持不變 -->
        <section id="about">
            <div class="two-col">
                <div class="profile">
                    <img src="aua.jpg" alt="Albert Chiu" />
                    <h3>albertchiu</h3>
                    <p>albertchiu931202@gmail.com</p>
                </div>
                <div class="content">
                    <h2>About Me</h2>
                    <p>An ordinary person who enjoys reading novels and playing games.</p>
                </div>
            </div>
        </section>

        <section id="gallery">
            <div class="gallery-img">
                <img src="aua.jpg" alt="Gallery Base" />
                <img src="aua2.png" alt="Overlay" class="overlay-img" />
                <a class="click-zone" href="https://www.youtube.com/watch?v=q6EoRBvdVPQ" target="_blank" title="Click to watch video"></a>
                <div class="overlay-text">Beard~</div>
            </div>
        </section>

        <section id="showcase">
            <h2>Timetable Style Adjuster</h2>
            <table id="course-table">
                <thead><tr><th>Monday</th><th>Tuesday</th><th>Wednesday</th></tr></thead>
                <tbody>
                    <tr><td>Math</td><td>English</td><td>Physics</td></tr>
                    <tr><td>History</td><td>Chemistry</td><td>Art</td></tr>
                    <tr><td>PE</td><td>Music</td><td>Biology</td></tr>
                </tbody>
            </table>
            <div class="btn-row">
                <button id="btn-width-200">Width 200px</button>
                <button id="btn-width-500">Width 500px</button>
            </div>
            <div class="btn-row">
                <button id="btn-border-1">Border spacing 1px</button>
                <button id="btn-border-10">Border spacing 10px</button>
                <button id="btn-border-20">Border spacing 20px</button>
            </div>
            <div class="btn-row">
                <button id="btn-color-pink">Pink</button>
                <button id="btn-color-lightblue">Light Blue</button>
                <button id="btn-color-lightgreen">Light Green</button>
            </div>
            <div class="btn-row">
                <button id="btn-reset">Reset</button>
            </div>

            <h2>Polaroid Image Switcher</h2>
            <div id="polaroid-container">
                <div id="polaroid-img">
                    <img id="polaroid-photo" src="t1.png" alt="Polaroid Image" />
                    <div id="polaroid-counter">Image 1 of 5</div>
                </div>
                <div class="polaroid-btns">
                    <button id="prev-btn">Previous</button>
                    <button id="next-btn">Next</button>
                </div>
            </div>
        </section>

        <section id="contact">
            <p>NTUT</p>
            <p>albertchiu</p>
            <p>albertchiu931202@gmail.com</p>
            <p>02-00000000</p>
        </section>
    </main>

    <script>
        /* ---------- 保持其他功能不變（導覽、表格、寶麗來） ---------- */
        const navLinks = document.querySelectorAll('nav a');
        const pages = document.querySelectorAll('main > section');
        navLinks.forEach(link => {
            link.addEventListener('click', e => {
                e.preventDefault();
                const target = link.dataset.target;
                pages.forEach(p => p.classList.remove('active'));
                document.getElementById(target).classList.add('active');
                navLinks.forEach(a => a.classList.remove('active'));
                link.classList.add('active');
            });
        });

        /* 表格控制（維持原樣） */
        const table = document.getElementById('course-table');
        const btnWidth200 = document.getElementById('btn-width-200');
        const btnWidth500 = document.getElementById('btn-width-500');
        const btnBorder1 = document.getElementById('btn-border-1');
        const btnBorder10 = document.getElementById('btn-border-10');
        const btnBorder20 = document.getElementById('btn-border-20');
        const btnColorPink = document.getElementById('btn-color-pink');
        const btnColorLightBlue = document.getElementById('btn-color-lightblue');
        const btnColorLightGreen = document.getElementById('btn-color-lightgreen');
        const btnReset = document.getElementById('btn-reset');

        btnWidth200.onclick = () => table.style.width = '200px';
        btnWidth500.onclick = () => table.style.width = '500px';
        btnBorder1.onclick = () => { table.style.borderSpacing = '1px'; table.style.borderWidth = '1px'; table.style.borderStyle = 'solid'; };
        btnBorder10.onclick = () => { table.style.borderSpacing = '10px'; table.style.borderWidth = '3px'; table.style.borderStyle = 'solid'; };
        btnBorder20.onclick = () => { table.style.borderSpacing = '20px'; table.style.borderWidth = '5px'; table.style.borderStyle = 'solid'; };
        btnColorPink.onclick = () => { table.style.background = '#ffccddee'; table.style.color = '#330011';[...table.querySelectorAll('th')].forEach(th => { th.style.background = '#dd99aa'; th.style.color = '#330011'; }) };
        btnColorLightBlue.onclick = () => { table.style.background = '#88ccffee'; table.style.color = '#003355';[...table.querySelectorAll('th')].forEach(th => { th.style.background = '#5599cc'; th.style.color = '#003355'; }) };
        btnColorLightGreen.onclick = () => { table.style.background = '#aaffccee'; table.style.color = '#004422';[...table.querySelectorAll('th')].forEach(th => { th.style.background = '#77bb88'; th.style.color = '#004422'; }) };
        btnReset.onclick = () => {
            table.style.width = '500px';
            table.style.borderSpacing = '10px';
            table.style.borderWidth = '3px';
            table.style.borderStyle = 'solid';
            table.style.background = '#003366';
            table.style.color = '#ddeeff';
            [...table.querySelectorAll('th')].forEach(th => { th.style.background = '#0055aa'; th.style.color = '#ddeeff'; });
        };

        /* Polaroid 圖片切換（維持原樣） */
        const polaroidImages = ['t1.png', 't2.png', 't3.png', 't4.png', 't5.png'];
        let currentIndex = 0;
        const photo = document.getElementById('polaroid-photo');
        const counter = document.getElementById('polaroid-counter');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        function updatePolaroid() { photo.src = polaroidImages[currentIndex]; counter.textContent = `Image ${currentIndex + 1} of ${polaroidImages.length}`; }
        prevBtn.onclick = () => { currentIndex = (currentIndex - 1 + polaroidImages.length) % polaroidImages.length; updatePolaroid(); };
        nextBtn.onclick = () => { currentIndex = (currentIndex + 1) % polaroidImages.length; updatePolaroid(); };

        /* ------------------ 首頁 Canvas（變更區） ------------------ */
        const canvas = document.getElementById('dream-canvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const cx = w / 2, cy = h / 2;

        /* 星星數量 200 */
        const starsCount = 200;
        const stars = [];
        class Star {
            constructor() { this.reset(); }
            reset() {
                this.angle = Math.random() * Math.PI * 2;
                this.r = Math.random() * 10;
                this.speed = 0.5 + Math.random() * 1.5;
                this.size = 1 + Math.random() * 1.5;
                this.alpha = 0.1 + Math.random() * 0.9;
            }
            update() {
                const cosA = Math.cos(this.angle);
                let maxR;
                if (Math.abs(cosA) < 0.0001) maxR = Math.max(w, h) * 2;
                else if (cosA > 0) maxR = (w - cx) / cosA;
                else maxR = (0 - cx) / cosA;
                this.r += this.speed * 0.6;
                if (this.r > Math.abs(maxR)) this.reset();
            }
            draw(ctx) {
                const x = cx + this.r * Math.cos(this.angle);
                const y = cy + this.r * Math.sin(this.angle);
                ctx.beginPath();
                ctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 4;
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        for (let i = 0; i < starsCount; i++) stars.push(new Star());

        function computeWindowPolygons() {
            const gap = 30;
            const innerHalfH = Math.max(10, h * 0.08);
            const outerHalfH = Math.max(30, h * 0.15);
            const windowWidth = Math.max(90, w * 0.30);
            const leftInnerX = cx - (gap / 2);
            const rightInnerX = cx + (gap / 2);
            const leftOuterX = leftInnerX - windowWidth;
            const rightOuterX = rightInnerX + windowWidth;
            const leftTopOuter = { x: leftOuterX, y: cy - outerHalfH };
            const leftTopInner = { x: leftInnerX, y: cy - innerHalfH };
            const leftBottomInner = { x: leftInnerX, y: cy + innerHalfH };
            const leftBottomOuter = { x: leftOuterX, y: cy + outerHalfH };
            const rightTopInner = { x: rightInnerX, y: cy - innerHalfH };
            const rightTopOuter = { x: rightOuterX, y: cy - outerHalfH };
            const rightBottomOuter = { x: rightOuterX, y: cy + outerHalfH };
            const rightBottomInner = { x: rightInnerX, y: cy + innerHalfH };
            return {
                left: [leftTopOuter, leftTopInner, leftBottomInner, leftBottomOuter],
                right: [rightTopInner, rightTopOuter, rightBottomOuter, rightBottomInner]
            };
        }

        function strokePoly(ctx, pts) {
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
            ctx.closePath();
            ctx.stroke();
        }
        function fillPoly(ctx, pts) {
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
            ctx.closePath();
            ctx.fill();
        }

        function roundRectPath(ctx, x, y, w, h, r) {
            const radius = Math.max(0, r);
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.arcTo(x + w, y, x + w, y + radius, radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);
            ctx.lineTo(x + radius, y + h);
            ctx.arcTo(x, y + h, x, y + h - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        function animate() {
            // 背景漸層（星空底）
            const grad = ctx.createRadialGradient(cx, cy, 10, cx, cy, Math.max(w, h));
            grad.addColorStop(0, '#001020'); grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);

            // 星星
            stars.forEach(s => { s.update(); s.draw(ctx); });

            // 計算觀察窗多邊形
            const polys = computeWindowPolygons();

            // 繪製灰色遮罩並在遮罩上切出窗（使用 evenodd 規則）
            ctx.save();
            ctx.fillStyle = 'rgba(120,120,120,1)';
            ctx.beginPath();
            ctx.rect(0, 0, w, h);
            ctx.moveTo(polys.left[0].x, polys.left[0].y);
            for (let i = 1; i < polys.left.length; i++) ctx.lineTo(polys.left[i].x, polys.left[i].y);
            ctx.closePath();
            ctx.moveTo(polys.right[0].x, polys.right[0].y);
            for (let i = 1; i < polys.right.length; i++) ctx.lineTo(polys.right[i].x, polys.right[i].y);
            ctx.closePath();
            ctx.fill('evenodd');

            // 裁剪到灰色區域（rect 減去窗），接著在灰色區域內繪製白色與其他形狀（不會進入窗內）
            ctx.beginPath();
            ctx.rect(0, 0, w, h);
            ctx.moveTo(polys.left[0].x, polys.left[0].y);
            for (let i = 1; i < polys.left.length; i++) ctx.lineTo(polys.left[i].x, polys.left[i].y);
            ctx.closePath();
            ctx.moveTo(polys.right[0].x, polys.right[0].y);
            for (let i = 1; i < polys.right.length; i++) ctx.lineTo(polys.right[i].x, polys.right[i].y);
            ctx.closePath();
            ctx.clip('evenodd');

            /* ===== 在灰色區域內繪製：頂部梯形（改為漸層：下方米白 -> 上方淺灰） ===== */
            // 計算窗跨越範圍（用於確定梯形寬度）
            const leftOuterX = polys.left[0].x;
            const rightOuterX = polys.right[1].x;
            const fullWindowSpan = rightOuterX - leftOuterX;
            const topWide = fullWindowSpan * 0.85; // 頂端較長，但比窗略小 (85%)
            const topNarrow = topWide * 0.36;      // 底端短一些 (36%)
            const topX1 = cx - topWide / 2, topX2 = cx + topWide / 2;
            // 可用的最上方 Y（在畫面頂部）
            const topY = 0;
            // 底端 Y：放在窗的最頂端上方一點（保留 6px 間隙）
            const windowsTopY = Math.min(...polys.left.map(p => p.y), ...polys.right.map(p => p.y));
            const topBottomY = Math.max(6, windowsTopY - 6);

            // 漸層：從下方（米白）到上方（淺灰）
            const topGrad = ctx.createLinearGradient(0, topBottomY, 0, topY);
            topGrad.addColorStop(0, '#f6efe0'); // 米白（下方）
            topGrad.addColorStop(1, '#dcdcdc'); // 淺灰（上方）

            ctx.fillStyle = topGrad;
            ctx.beginPath();
            ctx.moveTo(topX1, topY);
            ctx.lineTo(topX2, topY);
            ctx.lineTo(cx + topNarrow / 2, topBottomY);
            ctx.lineTo(cx - topNarrow / 2, topBottomY);
            ctx.closePath();
            ctx.fill();

            /* ===== 在灰色區域內繪製：底部凹邊形（仍為白色，且長邊縮為原來的1/3） ===== */
            // 底部起點（在畫布下方）：找電腦位置（稍後也會繪製電腦）
            const gapToWindow = 12;
            const leftBottomY = polys.left[3].y;
            const rightBottomY = polys.right[2].y;
            const windowsBottom = Math.max(leftBottomY, rightBottomY);
            const screenW = 120, screenH = 36;
            let screenY = Math.min(h - screenH - 8, windowsBottom + gapToWindow);
            if (screenY + screenH > h - 8) screenY = h - screenH - 8;
            const bottomTopY = screenY + screenH + 6;
            const bottomBottomY = h;
            const bottomTopWidth = Math.max(40, fullWindowSpan * 0.25);
            const bottomBottomWidthOriginal = Math.max(fullWindowSpan * 1.2, w * 0.9);
            const bottomBottomWidth = bottomBottomWidthOriginal / 3; // 縮為原來的 1/3
            const topLeftX = cx - bottomTopWidth / 2, topRightX = cx + bottomTopWidth / 2;
            const botLeftX = cx - bottomBottomWidth / 4, botRightX = cx + bottomBottomWidth / 4;

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(topLeftX, bottomTopY);
            const leftCp1x = topLeftX - (topLeftX - botLeftX) * 0.25 + 30; // 向內調整
            const leftCp1y = bottomTopY + (bottomBottomY - bottomTopY) * 0.35;
            const leftCp2x = topLeftX - (topLeftX - botLeftX) * 0.6 + 30;
            const leftCp2y = bottomTopY + (bottomBottomY - bottomTopY) * 0.75;
            ctx.bezierCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, botLeftX, bottomBottomY);
            ctx.lineTo(botRightX, bottomBottomY);
            const rightCp1x = topRightX + (botRightX - topRightX) * 0.25 - 30;
            const rightCp1y = bottomTopY + (bottomBottomY - bottomTopY) * 0.35;
            const rightCp2x = topRightX + (botRightX - topRightX) * 0.65 - 30;
            const rightCp2y = bottomTopY + (bottomBottomY - bottomTopY) * 0.75;
            ctx.bezierCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, topRightX, bottomTopY);
            ctx.closePath();
            ctx.fill();

            /* ===== 在灰色區域內描白邊（不會進入窗內，因為已裁剪） ===== */
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#ffffff';
            ctx.lineJoin = 'miter';
            strokePoly(ctx, polys.left);
            strokePoly(ctx, polys.right);

            // 結束裁剪區，回復繪圖狀態
            ctx.restore();

            /* --- 新增：在花瓶（椅子）下方繪製一個淺綠長方形（部分被椅子覆蓋），並把與觀察窗間的梯形也填成淺綠視為同一塊 --- */
            const windowBottom = windowsBottom; // 觀察窗底部
            const skyTopY = windowBottom; // 頂部切齊觀察窗底部
            const skyBottomY = bottomTopY; // 底部切齊下方白色梯形頂端
            // 只在 top < bottom 時繪製
            if (skyTopY < skyBottomY) {
                ctx.fillStyle = '#dff4d8'; // 淺綠
                // 主矩形（與觀察窗左右同寬）
                ctx.fillRect(leftOuterX, skyTopY, rightOuterX - leftOuterX, skyBottomY - skyTopY);

                // 額外繪製：觀察窗與該塊之間的梯形區域（同色）
                const trapTopLeftX = polys.left[3].x; // 觀察窗左下角
                const trapTopRightX = polys.right[2].x; // 觀察窗右下角
                ctx.beginPath();
                ctx.moveTo(trapTopLeftX, windowBottom);
                ctx.lineTo(trapTopRightX, windowBottom);
                ctx.lineTo(rightOuterX, skyBottomY);
                ctx.lineTo(leftOuterX, skyBottomY);
                ctx.closePath();
                ctx.fill();
            }

            /* --- 按使用者要求：先繪製深色（黑色）長方形圖層，然後在上面繪製淺灰色的 T 形（T 在深色層上方） --- */
            // 計算 T 與黑色矩形的基礎參數
            const tCenterX = cx;
            const tCenterY = bottomTopY + 12; // 靠近下方梯形頂端
            const tBarThickness = 18; // 窄邊寬度
            const tHorizontalWidth = tBarThickness * 3; // 長邊 = 3 * 窄邊
            const tHorizontalHeight = tBarThickness;
            const tVerticalWidth = tBarThickness;
            const tVerticalHeight = tBarThickness;
            const cornerR = 3;

            // 黑色直立長方形（底層）
            const blackW = Math.max(10, tVerticalWidth + 6); // 保持比窄邊寬一點
            const blackX = cx - blackW / 2;
            const blackYStart = bottomTopY + 4; // 從白色梯形下面開始
            const blackH = bottomBottomY - blackYStart;
            ctx.fillStyle = '#0b0b0b'; // 深色底層
            roundRectPath(ctx, blackX, blackYStart, blackW, blackH, cornerR);
            ctx.fill();

            // 在黑色上方繪製淺灰色 T 形
            ctx.fillStyle = '#dcdcdc'; // 淺灰色 T
            // 橫條
            const tHorizontalX = tCenterX - tHorizontalWidth / 2;
            const tHorizontalY = tCenterY - tHorizontalHeight / 2 - tVerticalHeight / 2; // 橫條在竪條頂端
            roundRectPath(ctx, tHorizontalX, tHorizontalY, tHorizontalWidth, tHorizontalHeight, cornerR);
            ctx.fill();
            // 竪條（T 的窄邊）
            const tVerticalX = tCenterX - tVerticalWidth / 2;
            const tVerticalY = tCenterY - tVerticalHeight / 2;
            roundRectPath(ctx, tVerticalX, tVerticalY, tVerticalWidth, tVerticalHeight, cornerR);
            ctx.fill();

            /* --- 花瓶：頂部靠近觀察窗底部（非對齊梯形），頂部切一個向下的圓弧（最大深度 20px） --- */
            // 期望花瓶高度
            const vaseDesiredH = 400;
            // 花瓶底部為畫面底部
            const vaseBottom = bottomBottomY;
            // 花瓶頂部靠近觀察窗底部（windowBottom）
            let vaseTop = windowBottom + 6; // 靠近但留一點空隙
            // 計算實際高度（不超過期望並保持在畫布內）
            let vaseH = Math.min(vaseDesiredH, vaseBottom - vaseTop);
            if (vaseH < 20) vaseH = Math.max(20, vaseBottom - vaseTop); // 防止過小
            const vaseTopY = vaseTop;
            const vaseBottomY = vaseBottom;

            // 寬度參數（已由你指定）
            const vaseMaxW = 150; // 最寬
            const vaseMinW = 100; // 最窄

            // 花瓶位置：左右對稱
            const vaseOffset = Math.min(fullWindowSpan * 0.38, cx - 80);
            const leftVaseCenter = cx - vaseOffset;
            const rightVaseCenter = cx + vaseOffset;

            function drawVase(centerX) {
                const topW = vaseMaxW; // 上寬
                const midW = vaseMinW; // 中央收縮
                const botW = vaseMaxW; // 下寬
                const vaseMidY = vaseTopY + vaseH * 0.45;

                // arc depth（向下切口），最大 20px
                const depth = Math.min(20, vaseH * 0.05);

                ctx.beginPath();
                // 從上部左點開始，先繪製向下的二次貝塞爾（近似圓弧）
                ctx.moveTo(centerX - topW / 2, vaseTopY);
                ctx.quadraticCurveTo(centerX, vaseTopY + depth, centerX + topW / 2, vaseTopY);

                // 右側：從 top -> mid
                ctx.bezierCurveTo(centerX + topW / 2 + 12, vaseTopY + 24, centerX + midW / 2 + 10, vaseMidY - 18, centerX + midW / 2, vaseMidY);
                // 右側：mid -> bottom
                ctx.bezierCurveTo(centerX + midW / 2 + 10, vaseMidY + 18, centerX + botW / 2 + 12, vaseBottomY - 18, centerX + botW / 2, vaseBottomY);
                // 底部橫線到左側
                ctx.lineTo(centerX - botW / 2, vaseBottomY);
                // 左側：bottom -> mid
                ctx.bezierCurveTo(centerX - botW / 2 - 12, vaseBottomY - 18, centerX - midW / 2 - 10, vaseMidY + 18, centerX - midW / 2, vaseMidY);
                // 左側：mid -> top
                ctx.bezierCurveTo(centerX - midW / 2 - 10, vaseMidY - 18, centerX - topW / 2 - 12, vaseTopY + 24, centerX - topW / 2, vaseTopY);

                ctx.closePath();
                // 皮革色填充
                ctx.fillStyle = '#8B5A2B'; // 皮革棕
                ctx.fill();
                // 描邊
                ctx.lineWidth = 1.2;
                ctx.strokeStyle = '#5f3d27';
                ctx.stroke();

                // 在花瓶上覆蓋一個深藍長方形（寬度 = 最窄處 midW，長度 = 花瓶實際高度）
                const blueW = midW;
                const blueH = vaseH;
                const blueX = centerX - blueW / 2;
                const blueY = vaseTopY;
                ctx.fillStyle = '#0b3d91'; // 深藍
                ctx.fillRect(blueX, blueY, blueW, blueH);
            }

            // 先繪製淺綠底（上方），再繪製花瓶（使其部分覆蓋底塊）
            drawVase(leftVaseCenter);
            drawVase(rightVaseCenter);

            /* --- 電腦與文字（在窗外繪製，保留與窗的間距） --- */
            const screenX = cx - screenW / 2;
            // 外框改為白色
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(screenX, screenY, screenW, screenH);
            // 中央黑面板（原先是淺黃，現改為黑）
            const margin = 5;
            ctx.fillStyle = '#000000';
            ctx.fillRect(screenX + margin, screenY + margin, screenW - margin * 2, screenH - margin * 2);
            // 文字改為綠色
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px monospace';
            const text = 'hello world!';
            const textX = screenX + 10;
            const textY = screenY + (screenH + 4) / 2;
            ctx.fillText(text, textX, textY);

            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
